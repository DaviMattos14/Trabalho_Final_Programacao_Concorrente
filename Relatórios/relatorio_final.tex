\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs} % para linhas mais bonitas nas tabelas
\usepackage{caption}  % para legenda
\usepackage{amsmath}  % Para o ambiente align* (alinhar equações)
\usepackage{siunitx}  % Para alinhar números decimais nas tabelas
\usepackage{float}    % Para a opção [H] (forçar a tabela a ficar "aqui")

\title{Leitura de arquivo .txt para contagem de palavras}
\author{Davi dos Santos Mattos \\
        Daniel Li Vam Man \\
        Pedro André Alves Chaves}
\date{Relatório Final \\ Programação Concorrente (ICP-361) - 2025/2}

\begin{document}

\maketitle

\section*{1. Descrição do problema geral}

O problema escolhido para o trabalho final foi a contagem de palavras em um \textit{arquivo.txt}. Uma tafera muito comum em aplicações de análise de dados, mineração de texto, recuperação da informação e processamento de linguagem neural.

Como bem sabemos, existem arquivos de diversos tamanhos, e dependendo da sua grandeza, existe um limite físico de processamento. Causando assim, estouro de memória, em outras palavras, o tamanho do arquivo é maior que o tamanho da memória disponível. Para evitar que esse tipo de problema aconteça, a solução mais adotada é particionar o arquivo em fragmentos menores que caibam na memória, para que assim seja possível seu processamento. Dessa forma, nos deparamos com um novo problema: dependendo da posição do particionamento para delimitar o fragmento, pode ocorrer de uma palavra ser particionada em duas partes.

A contagem por sua vez, entende que uma palavra consiste em uma sequência contínua de caracteres alfabéticos, ignorando se a letra está em caixa alta ou caixa baixa. Dentro de um texto, as palavras são delimitadas por separadores, que definimos no início do código, como espaços, pontuações, entre outros caracteres iniciais, que são responsáveis por marcar o início e o fim de uma palavra.

\begin{itemize}
    \item \textbf{Entrada}: Arquivo de Texto (.txt) qualquer.
    \item \textbf{Saída}: Número de palavras encontradas no arquivo
\end{itemize}

O problema se beneficia da concorrência quando temos que lidar com arquivos de texto muito grandes, pois podemos dividir o arquivo em fragmentos menores e colocar em uma fila de processamento, fazendo com que cada thread execute a tarefa de contagem de forma paralela, reduzindo drasticamente o tempo de processamento, e aumentando o desempenho.

\newpage
\section*{2. Projeto e implementação da solução concorrente}

O projeto consiste em fazer duas implementações: uma sequencial e outra concorrente, e realizar as avaliações de corretude e desempenho.

A solução sequencial consiste em um programa que lê o arquivo em fragmentos de até 1 KB usando a função fgets. A contagem de palavras é realizada em cada fragmento usando a função strtok, que divide a string com base nos separadores definidos.

Já a solução concorrente, por sua vez, consiste em utilizar o modelo produtor-consumidor, onde há uma única thread produtora lendo o arquivo e colocando fragmentos de 10KB do arquivo em uma fila compartilhada (buffer) entre as threads consumidoras.

Para solução sequencial definimos o seguinte escopo: 
\begin{itemize} 
    \item Fragmento de Leitura: até 1 KB. 
\end{itemize} 
Para a solução concorrente, foi definido: 
\begin{itemize} 
    \item Fragmento de Leitura: 10KB
    \item Tamanho do Buffer: 64 slots, totalizando 640 KB de capacidade. 
\end{itemize}

Vale destacar que as implementações também diferem na estratégia principal de I/O e contagem. A versão sequencial usa \texttt{fgets} (leitura baseada em linha/fragmento) e \texttt{strtok}, enquanto a versão concorrente utiliza \texttt{fread} (leitura otimizada de blocos brutos) e uma função \texttt{contar\_palavras} customizada, que percorre o texto manualmente com auxílio de uma tabela de separadores para consulta, sendo algoritmicamente mais eficiente.

Quando o programa subdivide o arquivo em blocos menores, pode ocorre de uma palavra ser fatiada ao meio, como por exemplo a palavra \textit{concorrente}, se ela estiver localizada no fim do bloco ela pode ser dividida em \textit{conco} e \textit{rrente}, com cada pedaço em um bloco diferente; Para tratar isso;

Na versão sequencial, é feita uma verificação no fragmento de leitura, se o fragmento terminar com um caracter, é utilizado uma flag para sinalizar que há uma palavra quebrada, caso na próxima leitura o fragmento começe com um caracter, a contagem é corrigida.

Já na versão concorrente, o tratamento de palavras quebradas é feito diretamente no produtor, antes de enviar os fragmentos às threads consumidoras.
Durante a leitura de cada fragmento, o produtor concatena o conteúdo restante do fragmento anterior (armazenado em um buffer de restos) com o novo bloco lido. Em seguida, o produtor procura o último separador válido dentro desse bloco. Se encontrar, ele divide o texto nesse ponto, o conteúdo antes do separador é inserido na fila para ser processado pelas threads, e o conteúdo após o separador é salvo no buffer de restos para ser unido ao próximo fragmento.

Dessa forma, garantimos que nenhuma palavra seja cortada entre dois fragmentos, e que as threads consumidoras recebam apenas blocos com palavras completas, eliminando a necessidade de tratar quebras dentro delas.

\section*{3. Testes de corretude}

Para testar a corretude da implementação, isto é, realizar a contagem correta de palavras de um arquivo, a implementação foi submetida a diferentes testes, alguns casos básicos, onde já se tem um resultado esperado, e outros casos mais realistas, onde se espera que ambas as versões apontem o mesmo resultado.

\subsection*{3.1 Escopo de entrada}
\begin{itemize}
    \item Testes Controlados
    \begin{itemize}
        \item Arquivo Teste: Consiste em um arquivo base no qual já se sabe o número total de palavras que ele contém. (\textbf{Resultado esperado}: 26)
        \item Arquivo Vazio (\textbf {Resultado esperado:} 0)
        \item Arquivo somente com separadores (\textbf{Resultado esperado}: 0)
        \item Arquivo de 100 KB (\textbf{Resultado esperado}: 14744)
        \item Arquivo de 1.5 MB (\textbf{Resultado esperado}: 264000)
    \end{itemize}
    \item Teste de Pariedade
    \begin{itemize}
        \item Arquivo de 500MB
        \item Arquivo de 1GB
        \item Arquivo de 2GB
        \item Arquivo de 4GB
    \end{itemize}
\end{itemize}

Para a versão concorrente foram utilizadas as seguintes quantidade de threads:

\begin{itemize}
    \item 2 threads
    \item 4 threads
    \item 8 threads
\end{itemize}

\subsection*{3.2 Resultados Obtidos}
Após executar os testes foram obtidos os seguintes resultados:

\begin{itemize}
    \item Arquivo Teste com as letras do alfabeto
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 26
        \item \textbf{Concorrente:} Número de palavras: 26
    \end{itemize}
    \item Arquivo Vazio
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 0
        \item \textbf{Concorrente:} Número de palavras: 0 
    \end{itemize}
    \item Arquivo somente com separadores
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 0
        \item \textbf{Concorrente:} Número de palavras: 0
    \end{itemize}
    \item Arquivo de 100 KB
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 14744
        \item \textbf{Concorrente:} Número de palavras: 14744
    \end{itemize}
    \item Arquivo de 1.5 MB:
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 264000
        \item \textbf{Concorrente:} Número de palavras: 264000
    \end{itemize}
    \item Arquivo de 500 MB:
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 87760050
        \item \textbf{Concorrente:} Número de palavras: 87760050
    \end{itemize}
    \item Arquivo de 1 GB:
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 175520100
        \item \textbf{Concorrente:} Número de palavras: 175520100
    \end{itemize}
    \item Arquivo de 2 GB:
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 351040200
        \item \textbf{Concorrente:} Número de palavras: 351040200
    \end{itemize}
    \item Arquivo de 4 GB:
    \begin{itemize}
        \item \textbf{Sequencial:} Número de palavras: 702080400
        \item \textbf{Concorrente:} Número de palavras: 702080400
    \end{itemize}
\end{itemize}

Tendo o resultados acima conclui-se a corretude do programa concorrente.

\newpage
\section*{4. Avaliação de desempenho}

Para realizar a avaliação selecionamos arquivos .txt de diversos tamanhos, todos foram submetidos a versão sequencial e a concorrente variando o número de threads.

\subsection*{4.1 Conjunto de casos de teste} 

\item Tamanho dos Arquivos
    \begin{itemize}
        \item \textbf{100 KB:}
        \item \textbf{1.5 MB:}
        \item \textbf{500 MB:}
        \item \textbf{1 GB:} 
        \item \textbf{2 GB:} 
        \item \textbf{4 GB:} 
    \end{itemize}
Como o método escolhido foi o produtor-consumidor, o número mínimo de threads concorrentes sempre será duas. Levando isso em consideração, para versão concorrente variamos o número de threads consumidoras entre \textbf{\{2, 4, 8\}}.
\begin{itemize}
    \item 2 threads (\textbf{1 Produtora e 1 Consumidora})
    \item 4 threads (\textbf{1 Produtora e 3 Consumidoras})
    \item 8 threads (\textbf{1 Produtora e 7 Consumidoras})
\end{itemize}

\subsection*{4.2 Configações das Máquinas para os Testes}
\begin{itemize}
    \item {Máquina 1}
    \begin{itemize}
        \item \textbf{Processador:} Intel(R) Core(TM) I5-7400 CPU @3.00GHz
        \item \textbf{Núcleos/Threads:} 4 / 4
        \item \textbf{Sistema Operacional:} Windows 10 
    \end{itemize}
    \item {Máquina 2} 
    \begin{itemize}
        \item \textbf{Processador:} Intel(R) Core(TM) i3-3110M CPU @ 2.40GHz
        \item \textbf{Núcleos/Threads:} 2 / 4
        \item \textbf{Sistema Operacional:} Windows 10
    \end{itemize}
    \item {Máquina 3}
    \begin{itemize}
        \item \textbf{Processador:}
        \item \textbf{Núcleos/Threads:}
        \item \textbf{Sistema Operacional:}
    \end{itemize}
\end{itemize}

    \subsection*{4.3 Resultados Obtidos}
    Cada caso de teste foi executado \textbf{15 vezes} (5 vezes em cada máquina de teste), para cada caso de teste foi medido seu tempo de execução. Para versão sequencial, a contagem se inicia no momento que é iniciada a leitura do arquivo, e para a versão concorrente, no momento de criação das threads. 
    
    A medida de tempo escolhida para realizar a avaliação foi o tempo médio em segundos, visando mitigar variações/ruídos do sistema operacional, com o objetivo de obter um resultado mais estável e confiável.

    Utilizamos quatro métricas para realizar a avaliação;
    
    \textbf{Aceleração}, que mede o quanto a versão paralela é mais rápida que a versão sequencial;
    
    \textbf{Eficiência}, mede o quão bem os recursos (as $n$ threads) foram utilizados;
    
    \textbf{Custo}, que mede o total de "tempo de CPU" que o programa consumiu em todas as threads;
    
    \textbf{Sobrecarga total}, que é a diferença entre o custo total da execução paralela e o custo da execução sequencial.

\begin{itemize}
\item Tempos médios obtidos
    \begin{table}[H]
        \centering
        \begin{tabular}{lcccccc}
            \toprule
            \textbf{Nº de Threads} & \textbf{100KB} & \textbf{1.5MB} & \textbf{500MB} & \textbf{1GB} & \textbf{2GB} & \textbf{4GB} \\
            \midrule
            Sequencial & 0.006 & 0.099 & 27.457 & 52.510 & 100.712 & 200.780 \\
            2 threads             & 0.002 & 0.023  & 7.816  & 15.973 & 31.119  & 63.168  \\
            4 threads             & 0.002 & 0.0267 & 8.215  & 16.475 & 32.969  & 66.725  \\
            8 threads             & 0.003 & 0.036  & 8.267  & 16.580 & 33.202  & 66.977  \\
            \bottomrule
        \end{tabular}
    \end{table}
    
\item Aceleração
    \begin{equation}
    A_n = T_s / T_n
    \end{equation}
Onde,
\begin{itemize}
    \item $A_n$ = Aceleração para $n$ threads.
    \item $T_s$ = Tempo de execução Sequencial 
    \item $T_n$ = Tempo de execução Paralela usando $n$ threads.
\end{itemize}

    \begin{table}[h!]
    \centering
    \begin{tabular}{lllllll}
    \toprule
    Aceleração $A_n$    & 100KB & 1.5MB & 500MB & 1GB  & 2GB  & 4GB  \\
    \midrule
    2 threads & 0.50  & 3.00     & 3.51  & 3.30 & 3.22 & 3.19 \\
    4 threads & 0.40  & 3.10  & 3.35  & 3.20 & 3.05 & 3.02 \\
    8 threads & 0.44  & 1.00     & 3.33  & 3.17 & 3.04 & 3.00  \\
        \bottomrule
    \end{tabular}
    \end{table}
    
\item Eficiência
\begin{equation}
    E_n = \frac{A_n}{n}
\end{equation}
Onde,
\begin{itemize}
    \item $E_n$ = Eficiência para $n$ threads.
    \item $A_n$ = Aceleração
    \item $n$ = O número de threads usados 
\end{itemize}
     \begin{table}[h!]
    \centering
    \begin{tabular}{lllllll}
    \toprule
    Eficiência $E_n$    & 100KB & 1.5MB & 500MB & 1GB  & 2GB  & 4GB  \\
    \midrule
    2 threads & 24.95\%  &  149,99\%    & 175,64\%  & 164,50\% & 161,19\% & 159,74\% \\
    4 threads & 10,04\%  & 77,49\%  & 83,41\%  & 79,99\% & 76,33\% & 75,48\% \\
    8 threads & 3,49\%  & 7,99\%     & 26,62\%  & 25,37\% & 38,04\% & 37,53\%  \\
        \bottomrule
    \end{tabular}
    \end{table}
\item Custo
\begin{equation}
    C_n = n \times T_n
\end{equation}

\begin{table}[H]
\centering
\label{tab:custo}
% Configura as colunas 'S' para alinhar pelo decimal
\begin{tabular}{l S[table-format=1.2]
                  S[table-format=2.2]
                  S[table-format=2.2]
                  S[table-format=2.2]
                  S[table-format=2.2]
                  S[table-format=2.2]}
\toprule
\textbf{Custo $C_p$} & {\textbf{100KB}} & {\textbf{1.5MB}} & {\textbf{500MB}} & {\textbf{1GB}} & {\textbf{2GB}} & {\textbf{4GB}} \\
\midrule
2 threads & 1.00 & 6.00 & 7.03 & 6.59 & 6.45 & 6.39 \\
4 threads & 1.61 & 12.40 & 13.35 & 12.80 & 12.21 & 12.08 \\
8 threads & 3.50 & 7.99 & 26.63 & 25.37 & 24.35 & 24.02 \\
\bottomrule
\end{tabular}
\end{table}

\item Sobrecarga Total (Overhead)
\begin{equation}
    T_o = C_n - T_s = (n \times T_n) - T_s
\end{equation}

\begin{table}[H]
\centering
\label{tab:sobrecarga}
% Configura as colunas 'S' para lidar com sinais negativos e casas decimais
\begin{tabular}{l S[table-format=-1.2]
                  S[table-format=-1.2]
                  S[table-format=-2.2]
                  S[table-format=-2.2]
                  S[table-format=-3.2]
                  S[table-format=-3.2]}
\toprule
\textbf{Sobrecarga $T_o$} & {\textbf{100KB}} & {\textbf{1.5MB}} & {\textbf{500MB}} & {\textbf{1GB}} & {\textbf{2GB}} & {\textbf{4GB}} \\
\midrule
2 threads & 0.9923 &  5.9004 &  -20.4315 &  -45.9158  & -94.2646 & -194.3911 \\
4 threads & 1.6019 & 12.3004 &  -14.1108 & -39.7108 &  -88.4982 & -188.704 \\
8 threads & 3.4915 & 7.8955 & -0.8287 & -27.1406  & -76.3655 & -176.7579 \\
\bottomrule
\end{tabular}
\end{table}
\end{itemize}
\newpage
\section*{5. Discussão}

Apresentar uma análise dos resultados obtidos:

\begin{itemize}
    \item discutir se o ganho de desempenho — ou as vantagens pretendidas com a solução
    concorrente — foram alcançadas ou não e por quais motivos;
    \item apresentar possíveis melhorias do programa, se for o caso;
    \item discutir outras questões que forem pertinentes;
    \item descrever dificuldades encontradas para a realização do trabalho, se for o caso.
\end{itemize}

\subsection*{5.1 Discussão sobre o ganho de desempenho} 
Analisando os resultados obtidos podemos ver que a versão concorrente reduziu o tempo numa média 3 vezes em relação ao sequencial, o que por sua vez é um ganho considerável, principalmente quando se trata de arquivos muitos grandes, cumprindo assim o objetivo principal do projeto.

Através dos resultados podemos ver também como a limitação física impacta no desempenho, pois como a média de núcleos/threads dos processadores das máquinas utilizadas é de 3/4, podemos ver tanto na tabela de eficiencia, quanto na tabela de custo, que quando aumentamos o número de threads de 4 para 8, perdemos em eficiência e aumentamos o custo. A pesar do tempo médio e aceleração serem relativamente próximos.

O mesmo pode ser visto se analisarmos os casos com 2 e 4 threads, pois como uma das máquinas tem menos núcleos/threads que as outras, nos casos com menos threads, a mesma apontaraá mais eficiência frente aos casos com mais thread, que pode explicar a maior média de eficiência no caso com apenas 2 threads.  


\subsection*{5.2 Possíveis Melhorias do Programa} 

\item \textbf{Otimizar o Produtor:} foi observado através dos testes que o gargalo presente no código é causado pelo produtor, cuja lógica para a preparação dos blocos é ineficiente, devido ao uso das funções de string de C (strcpy, strcat, strlen), que percorrem os blocos de dados.
\item \textbf{Flexibilização dos Parâmetros:} permitir a passagem dos parâmetros para o tamanho da fila e para o tamanho da leitura, sendo possível dessa forma encontrar num ponto de equilíbrio para a quantidade de threads e tamanho dos arquivos


\subsection*{5.3 Questões Pertinentes} 

\subsection*{5.4 Dificuldades encontradas} 
\item\textbf{Resultados Contraintuitivos:} era esperado que 4 threads fossem mais rápidas que 2, e os dados obtidos mostraram um resultado oposto, exigindo dessa forma uma análise mais profunda na tentativa de identificar o verdadeiro gargalo, que foi a descoberta de que o Produtor estava bem mais lento que os Consumidores.
\item \textbf{Implementação da lógica da quebra em blocos}: conforme já esperado pelo grupo, a implementação da lógica de quebra dos blocos se mostrou bastante complexa, exigindo bastante tempo de desenvolvimento.

\newpage
\section*{6. Referências bibliográficas}
\begin{thebibliography}{9}
    \bibitem{exemplo1}
    Rossetto, S. \textbf{Slides de Aula}. 

    \bibitem{exemplo2}
    Fernandes, M. \textbf{TCC - Análise de ferramentas de teste no contexto de aprendizado de programação concorrente, 2021}. 

    \bibitem{exemplo3}
    Maratona de programação paralela (Mackenzie). Disponível em: http://lspd.mackenzie.br/marathon/old.html. 

    \bibitem{exemplo4}
    P. Pacheco, \textbf{An Introduction to Parallel Programming}, Morgan Kaufmann, 2011.

    \bibitem{exemplo5}
    Martin Porter’s Stemming algorithm as a C library. Disponível em: https://github.com/wooorm/stmr.c

    
\end{thebibliography}

\end{document}
